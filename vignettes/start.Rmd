---
title: "Getting Started with `grizbayr`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Getting Started with `grizbayr`}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
library(dplyr)
```

## About the Package

Bayesian Inference is a method of statistical inference that can be used in the analysis of observed data from marketing tests. Bayesian updates start with a prior distribution (prior probable information about the environment) and a likelihood function (an expected distribution from which the samples are drawn). Then, given some observed data, the prior can be multiplied by the likelihood of the data to produce a posterior distribution of probabilities. At the core of all of this is Bayes' Rule. 

$$ P(A\ |\ Data) \sim P(Data\ |\ A) \cdot P(A)$$
This package is intended to abstract the math of the conjugate prior update rules to provide 3 pieces of information for a user:

1. Win Probability
1. Value Remaining
1. Lift vs. Control

## Usage

Select which piece of information you would like to calculate.

| Metric                       | Function Call                     |
|------------------------------|-----------------------------------|
| Win Probability              | `estimate_win_prob()`             |
| Value Remaining              | `estimate_value_remaining()`      |
| Lift vs. Control             | `estimate_lift()`                 |
| Win Probability vs. Baseline | `estimate_win_prob_vs_baseline()` |

If you would like to calculate all the metrics then use `calculate_all_metrics()`. This is a slightly more efficient implementation since it only needs to sample from the posterior once for all 4 calculations instead of once for each metric.

### Create an Input Dataframe or Tibble

All of these functions require a very specific tibble format. However, the same tibble can be used in all metric calculations. A tibble is used here because it has the additional check that all column lengths are the same. A tibble of this format can also conveniently be created using dplyr's `group_by() %>% summarise()` sequence of functions.

The columns in the following table are required if there is an `X` in the box for the distribution. (Int columns can also be dbl due to R coercian)

| Distribution Type         | option_name (char) | sum_impressions (int) | sum_clicks (int) | sum_sessions (int) | sum_conversions (dbl) | sum_revenue (dbl) | sum_cost (dbl) | sum_conversions_2 (dbl) | sum_revenue_2 (dbl) |
|---------------------------|:------------------:|:---------------------:|:----------------:|:------------------:|:---------------------:|:-----------------:|:--------------:|:-----------------------:|:-------------------:|
| Conversion Rate           |          X         |                       |         X        |                    |           X           |                   |                |                         |                     |
| Response Rate             |          X         |                       |                  |          X         |           X           |                   |                |                         |                     |
| Click Through Rate (CTR)  |          X         |           X           |         X        |                    |                       |                   |                |                         |                     |
| Revenue Per Session       |          X         |                       |                  |          X         |           X           |         X         |                |                         |                     |
| Multi Revenue Per Session |          X         |                       |                  |          X         |           X           |         X         |                |             X           |           X         |
| Cost Per Activation (CPA) |          X         |                       |         X        |                    |           X           |                   |        X       |                         |                     |
| Total CM                  |          X         |           X           |         X        |                    |           X           |         X         |        X       |                         |                     |
| CM Per Click              |          X         |                       |         X        |                    |           X           |         X         |        X       |                         |                     |
| Cost Per Click (CPC)      |          X         |                       |         X        |                    |                       |                   |        X       |                         |                     |

#### Example:
We will use the Conversion Rate distribution for this example so we need the columns **option_name**, **sum_clicks**, and **sum_conversions**.

```{r}
raw_data_long_format <- tibble::tribble(
   ~option_name, ~clicks, ~conversions,
            "A",       6,           3,
            "A",       1,           0,
            "B",       2,           1,
            "A",       2,           0,
            "A",       1,           0,
            "B",       5,           2,
            "A",       1,           0,
            "B",       1,           1,
            "B",       1,           0,
            "A",       3,           1,
            "B",       1,           0,
            "A",       1,           1
)

raw_data_long_format %>% 
  dplyr::group_by(option_name) %>% 
  dplyr::summarise(sum_clicks = sum(clicks), 
                   sum_conversions = sum(conversions))
```
This input dataframe can also be created manually if the aggregations are already done in an external program.

```{r}
input_df <- tibble::tibble(
  option_name = c("A", "B"),
  sum_clicks = c(1000, 1000),
  sum_conversions = c(100, 120)
)
input_df
```

`input_df` is used in the following examples. 

### Win Probability
`estimate_win_prob(input_df, distribution = "conversion_rate")`

### Value Remaining (Loss)
`estimate_value_remaining(input_df, distribution = "conversion_rate")`

The `metric` argument defaults to `relative` which produces a percent lift vs the baseline. Sometimes we may want to understand this lift in absolute terms (especially when samples from the posteriors could be negative, such as Contribution Margin (CM).)

`estimate_value_remaining(input_df, distribution = "conversion_rate", metric = "absolute)`


### Estimate Lift
`estimate_lift(input_df, distribution = "conversion_rate", baseline_option = "A")`

`estimate_lift(input_df, distribution = "conversion_rate", baseline_option = "A", metric = "absolute")`

### Win Probability vs. Baseline
`estimate_win_prob_vs_baseline(input_df, distribution = "conversion_rate", baseline_option = "A")`

### Estimate All Metrics
`estimate_all_metrics(input_df)`

### Sample From the Posterior
`sample_from_posterior(input_df, distribution = "conversion_rate)`

## Valid Posteriors
Beta - alpha0, beta0
Gamma - k0, theta0 (k01, theta01 if alternate Gamma priors are required)
Dirichlet - alpha_00 (none), alpha_01 (first conversion type), alpha_02 (alternate conversion type)
